---
title: "snATACseq data processing"
output: html_notebook
date: 'Created on: `r format(Sys.Date(), "%B %d, %Y")`'
---

This dataset contains nuclei of CD45+CD11b+F4/80+CD115+ FACS sorted monocyte enriched cells from mouse E14 fetal liver and adult bone marrow. The input files can be downloaded from GSE292830.

The mouse brain Signac vignette was followed for the data processing: https://stuartlab.org/signac/articles/mouse_brain_vignette 

```{r}
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(Signac))
suppressPackageStartupMessages(library(Seurat, lib.loc="/home/daliya/Apps/Seurat.v4"))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(clustree))
suppressPackageStartupMessages(library(plotly))
suppressPackageStartupMessages(library(presto))
suppressPackageStartupMessages(library(scater))
suppressPackageStartupMessages(library(EnsDb.Mmusculus.v79))
```

Set the working directory
```{r setup}
knitr::opts_knit$set(root.dir = "~/Documents/Kia/Jonathan/JBA1-2_ATAC/results/")
```

```{r}
sample.names<-c("JBA1","JBA2")
sample.description=c("BM","Fetal liver")
mm10.blacklist = rtracklayer:: import(gzfile(  "mm10.blacklist.bed.gz")) ### Blacklist downloaded from https://github.com/Boyle-Lab/Blacklist?tab=readme-ov-file
```


### Pre-processing 
When pre-processing chromatin data, Signac uses information from two related input files, both of which can be created using CellRanger:

   - Peak/Cell matrix. This is analogous to the gene expression count matrix used to analyze single-cell RNA-seq. However, instead of genes, each row of the matrix represents a region of the genome (a peak), that is predicted to represent a region of open chromatin. Each value in the matrix represents the number of Tn5 integration sites for each single barcode (i.e. a cell) that map within each peak. You can find more detail on the 10X Website.
   - Fragment file. This represents a full list of all unique fragments across all single cells. It is a substantially larger file, is slower to work with, and is stored on-disk (instead of in memory). However, the advantage of retaining this file is that it contains all fragments associated with each single cell, as opposed to only fragments that map to peaks. More information about the fragment file can be found on the 10x Genomics website or on the sinto website.

We start by creating a Seurat object using the peak/cell matrix and cell metadata generated by cellranger-atac, and store the path to the fragment file on disk in the Seurat object:

```{r}
seur=list()
for (i in 1:length(sample.names)){
chrassay<- CreateChromatinAssay(
  counts =  Read10X_h5(paste0(sample.names[i],"/filtered_peak_bc_matrix.h5")),
  sep = c(":", "-"),
  genome = "mm10",
  fragments = paste0(sample.names[i],'/fragments.tsv.gz'),
  min.cells = 1,
  verbose =F
)
metadata <- read.csv(paste0(sample.names[i],"/singlecell.csv"),  header = TRUE,row.names = 1)
seur[[i]] <- CreateSeuratObject(
  counts = chrassay,
  assay = 'peaks',
  project = 'ATAC',
  meta.data = metadata
)
seur[[i]]$sample=sample.names[i]
seur[[i]]$origin=sample.description[i]
}
rm(chrassay)
rm(metadata)
```

We can also add gene annotations to the brain object for the mouse genome. This will allow downstream functions to pull the gene annotation information directly from the object.


```{r}
annotations <- GetGRangesFromEnsDb(ensdb = EnsDb.Mmusculus.v79, verbose=F)

# change to UCSC style since the data was mapped to hg19
seqlevels(annotations) <- paste0('chr', seqlevels(annotations))
genome(annotations) <- "mm10"

# add the gene information to the object

for (i in 1:length(sample.names)){
Annotation(seur[[i]]) <- annotations
}

```


### Computing QC Metrics
```{r}
for (i in 1:length(sample.names)){
seur[[i]] <- NucleosomeSignal(object = seur[[i]], verbose=F)
}
```

- Nucleosome banding pattern
We can look at the fragment length periodicity for all the cells, and group by cells with high or low nucleosomal signal strength. Cells which are outliers for the mononucleosomal/ nucleosome-free ratio have different banding patterns. The remaining cells exhibit a pattern that is typical for a successful ATAC-seq experiment.

```{r , fig.height = 6, fig.width = 12}
for (i in 1:length(sample.names)){
seur[[i]]$nucleosome_group <- ifelse(seur[[i]]$nucleosome_signal > 4, 'NS > 4', 'NS < 4')
print(FragmentHistogram(object = seur[[i]], group.by = 'nucleosome_group', region = 'chr1-1-10000000'))
}
```

-  TSS enrichment score
The enrichment of Tn5 integration events at transcriptional start sites (TSSs) can also be an important quality control metric to assess the targeting of Tn5 in ATAC-seq experiments. The ENCODE consortium defined a TSS enrichment score as the number of Tn5 integration site around the TSS normalized to the number of Tn5 integration sites in flanking regions. See the ENCODE documentation for more information about the TSS enrichment score (https://www.encodeproject.org/data-standards/terms/). 

```{r}
for (i in 1:length(sample.names)){
seur[[i]] <- TSSEnrichment(seur[[i]], verbose=F)
}
```

- Fraction of fragments in peaks
Represents the fraction of all fragments that fall within ATAC-seq peaks. Cells with low values (i.e. <15-20%) often represent low-quality cells or technical artifacts that should be removed. Note that this value can be sensitive to the set of peaks used.
```{r}
for (i in 1:length(sample.names)){
seur[[i]] $pct_reads_in_peaks <- seur[[i]] $peak_region_fragments / seur[[i]] $passed_filters * 100
}
```

- Total number of fragments in peaks: "peak_region_fragments" metric, calculated by CellRanger
A measure of cellular sequencing depth / complexity. Cells with very few reads may need to be excluded due to low sequencing depth. Cells with extremely high levels may represent doublets, nuclei clumps, or other artefacts.

- Ratio reads in genomic blacklist regions
The ENCODE project has provided a list of blacklist regions, representing reads which are often associated with artefactual signal. Cells with a high proportion of reads mapping to these areas (compared to reads mapping to peaks) often represent technical artifacts and should be removed.
```{r}
seur[[i]]$blacklist_ratio <- FractionCountsInRegion(
  object = seur[[i]], 
  assay = 'peaks',
  regions = mm10.blacklist
)
```



### Fidning outlier nuclei 
The exact QC thresholds for removing outliers need to be adjusted according to the dataset.
Here, we use the isOutlier() function from the scuttle package. It defines an observation as an outlier if it is more than a specified number of median absolute deviations (MADs, default 3) from the median in the specified direction.

```{r}
  j= 'nucleosome_signal'
for (i in 1:length(sample.names)){
  outliers= scuttle::isOutlier(seur[[i]]@meta.data[,j], nmads=6, type="higher", log=TRUE)
  attr(outliers, "thresholds") <- NULL
 seur[[i]]@meta.data[paste0(j,".outlier.higher")] <- outliers
  cat(sample.names[i],j,"outliers higher :",sum(seur[[i]]@meta.data[paste0(j,".outlier.higher")]),"\n")
}

for ( j in c('pct_reads_in_peaks','TSS.enrichment')){
 for (i in 1:length(sample.names)){
    outliers= scater::isOutlier(seur[[i]]@meta.data[,j], nmads=6, type="lower", log=TRUE)
  attr(outliers, "thresholds") <- NULL
 seur[[i]]@meta.data[paste0(j,".outlier.lower")] <- outliers
  cat(sample.names[i],j,"outliers lower :",sum(seur[[i]]@meta.data[paste0(j,".outlier.lower")]),"\n")
  }
}

j='peak_region_fragments'
for (i in 1:length(sample.names)){
    outliers= scater::isOutlier(seur[[i]]@meta.data[,j], nmads=2, type="lower", log=TRUE)
  attr(outliers, "thresholds") <- NULL
 seur[[i]]@meta.data[paste0(j,".outlier.lower")] <- outliers
  cat(sample.names[i],j,"outliers lower :",sum(seur[[i]]@meta.data[paste0(j,".outlier.lower")]),"\n")
}

j="blacklist_ratio"
for (i in 1:length(sample.names)){
  outliers= scater::isOutlier(seur[[i]]@meta.data[,j], nmads=3, type="higher", log=TRUE)
  attr(outliers, "thresholds") <- NULL
 seur[[i]]@meta.data[paste0(j,".outlier.higher")] <- outliers
  cat(sample.names[i],j,"outliers higher :",sum(seur[[i]]@meta.data[paste0(j,".outlier.higher")]),"\n")
}
```



```{r , fig.height = 3.5, fig.width = 10}
for ( j in c('peak_region_fragments','pct_reads_in_peaks', 'nucleosome_signal',
               'TSS.enrichment', "blacklist_ratio")){
  for (i in 1:length(sample.names)){
     hist(seur[[i]]@meta.data[,j],
        breaks = 100,xlab=j,
        main=paste0(j,": ",sample.names[i]))
    if (paste0(j,".outlier.higher") %in% colnames(seur[[i]]@meta.data) ){
      if(sum(seur[[i]]@meta.data[paste0(j,".outlier.higher")]) !=0 )
       abline(v = min(seur[[i]]@meta.data[,j][unlist(seur[[i]]@meta.data[paste0(j,".outlier.higher")])]), col = "red")
    }
   if (paste0(j,".outlier.lower") %in% colnames(seur[[i]]@meta.data) ){
    if(sum(seur[[i]]@meta.data[paste0(j,".outlier.lower")]) !=0 )
   abline(v = max(seur[[i]]@meta.data[,j][unlist(seur[[i]]@meta.data[paste0(j,".outlier.lower")])]), col = "red")
   }
  }
}
```



We remove cells that are outliers for these QC metrics.

```{r}
for (i in 1:length(sample.names)){
seur[[i]]  <- seur[[i]] [,!(seur[[i]]$peak_region_fragments.outlier.lower | 
    seur[[i]]$pct_reads_in_peaks.outlier.lower | 
    seur[[i]]$nucleosome_signal.outlier.higher  | 
    seur[[i]]$TSS.enrichment.outlier.lower |
   seur[[i]]$blacklist_ratio.outlier.higher   )]

print(sample.names[i])
print(seur[[i]] )
}
```


```{r}
seur<-merge(seur[[1]],seur[2:length(seur)])
```


### Normalization and linear dimensional reduction

    Normalization: Signac performs term frequency-inverse document frequency (TF-IDF) normalization. This is a two-step normalization procedure, that both normalizes across cells to correct for differences in cellular sequencing depth, and across peaks to give higher values to more rare peaks.

    Feature selection: The low dynamic range of scATAC-seq data makes it challenging to perform variable feature selection, as we do for scRNA-seq. Instead, we can choose to use only the top n% of features (peaks) for dimensional reduction, or remove features present in less than n cells with the FindTopFeatures() function. Here we will use all features, though we have seen very similar results when using only a subset of features (try setting min.cutoff to ‘q75’ to use the top 25% all peaks), with faster runtimes. Features used for dimensional reduction are automatically set as VariableFeatures() for the Seurat object by this function.

    Dimension reduction: We next run singular value decomposition (SVD) on the TD-IDF matrix, using the features (peaks) selected above. This returns a reduced dimension representation of the object (for users who are more familiar with scRNA-seq, you can think of this as analogous to the output of PCA).

The combined steps of TF-IDF followed by SVD are known as latent semantic indexing (LSI), and were first introduced for the analysis of scATAC-seq data by Cusanovich et al. 2015.
```{r}
seur <- RunTFIDF(seur,verbose =F)
seur <- FindTopFeatures(seur, min.cutoff = 'q0',verbose =F)
seur <- RunSVD(object = seur,verbose =F)
```
The first LSI component often captures sequencing depth (technical variation) rather than biological variation. If this is the case, the component should be removed from downstream analysis. We can assess the correlation between each LSI component and sequencing depth using the DepthCor() function:


```{r , fig.height = 3.5, fig.width = 5}
DepthCor(seur)
```
```{r , fig.height = 4, fig.width = 6}
ElbowPlot(object = seur,ndims =50, reduction = "lsi")
```


Non-linear dimension reduction and clustering

Now that the cells are embedded in a low-dimensional space we can use methods commonly applied for the analysis of scRNA-seq data to perform graph-based clustering and non-linear dimension reduction for visualization. The functions RunUMAP(), FindNeighbors(), and FindClusters() all come from the Seurat package.

```{r}
### LSI components selection for downstream analysis
dims.use<-30
```


```{r}
seur <- RunUMAP(object = seur, reduction = 'lsi', dims = 2:dims.use,verbose =F)
seur <- FindNeighbors(seur,  reduction = 'lsi',dims = 2:dims.use, verbose=F, graph.name=paste0("ATAC_snn_LSI",dims.use))
for ( i in seq(0,2, 0.25))
  seur <- FindClusters(seur, resolution = i, algorithm = 3, graph.name=paste0("ATAC_snn_LSI",dims.use), verbose=F) 
```


```{r , fig.height = 8, fig.width = 10}
clustree::clustree(seur, prefix = paste0("ATAC_snn_LSI",dims.use,"_res."))+
  ggtitle(paste("LSI =",dims.use))
```

```{r , fig.height = 8, fig.width = 12}
plot<-list()
for ( res in c(0.25,0.5,0.75,1))
  plot[[as.character(res)]]<-DimPlot(seur,label=T,repel=T, group.by = paste0("ATAC_snn_LSI",dims.use,"_res.",res))+
                                      ggtitle(paste("LSI =",dims.use,"res=",res))
plot_grid(plotlist=plot)
```


```{r , fig.height = 4, fig.width = 5}
DimPlot(seur,repel =T,label=T, group.by = "origin") 
```


### Create a gene activity matrix
We can try to quantify the activity of each gene in the genome by assessing the chromatin accessibility associated with the gene, and create a new gene activity assay derived from the scATAC-seq data. Here we will use a simple approach of summing the fragments intersecting the gene body and promoter region

To create a gene activity matrix, we extract gene coordinates and extend them to include the 2 kb upstream region (as promoter accessibility is often correlated with gene expression). We then count the number of fragments for each cell that map to each of these regions, using the using the FeatureMatrix() function. These steps are automatically performed by the GeneActivity() function:

```{r}
gene.activities <- GeneActivity(seur,verbose =F)

seur[['RNA']] <- CreateAssayObject(counts = gene.activities)
 # add the gene activity matrix to the Seurat object as a new assay and normalize it                               
seur <- NormalizeData(
  object = seur,
  assay = 'RNA',
  normalization.method = 'LogNormalize',
  scale.factor = median(seur$nCount_RNA),
  verbose =F
)
seur <- ScaleData(seur, assay = 'RNA',verbose =F)
```


```{r}
DefaultAssay(seur) <- 'RNA'
res=0.5
Idents(seur)=  paste0("ATAC_snn_LSI",dims.use,"_res.",res)
Idents(seur)=  factor(Idents(seur),levels = 0:(length(unique(Idents(seur)))-1))
DEgenes=list()
for (i in levels(Idents(seur))){
 DEgenes[[i]]<-FindMarkers(seur, ident.1 = i,min.cells.group=2,pseudocount.use = 0.01, max.cells.per.ident = 1000)
 DEgenes[[i]]$cluster=i
 DEgenes[[i]]$pseudocount=0.01
 DEgenes[[i]]$max.cells.per.ident=1000
 DEgenes[[i]]$gene=row.names(DEgenes[[i]])
}
```


```{r}
features.use=unlist(lapply(DEgenes, function(x) { head(x[x$avg_log2FC>0,]$gene,7)}))
length(features.use)
names(features.use)=NULL
features.use=features.use[!duplicated(features.use)]
```

```{r , fig.height = 4, fig.width = 5}
DimPlot(seur,repel =T,label=T) 
```

```{r , fig.height =4, fig.width =14}
DotPlot(seur, features = features.use)+RotatedAxis()+NoLegend()
```


```{r}
Idents(seur) <- plyr::mapvalues(x = Idents(seur), from = 0:10, 
    to =c("FL 2", "BM 3","BM 1","FL 1","BM 4","BM 2",
          "FL 3", "FL 5", "Erythroid","FL 4","Lymphoid"))
```

```{r}
new.order=c (  "FL 1", "FL 2" , "FL 3" ,  "FL 4","FL 5" ,  "BM 1"  , "BM 2", "BM 3"   ,  "BM 4" ,  "Erythroid" , "Lymphoid"       )
new.order[!new.order %in% levels( Idents(seur))]
levels( Idents(seur))[!levels( Idents(seur)) %in%new.order]
```



```{r}
Idents(seur)=factor( Idents(seur), levels=new.order)
seur$annot=Idents(seur)
```
```{r , fig.height = 6, fig.width = 8}
DimPlot(seur,repel =T,label=T) 
```


```{r , fig.height = 4, fig.width =14}
DotPlot(seur, features=c("Ptprc","Flt3","Tshz2","Igf2bp3" , "Gli2","Cd34","Prtn3","Kit","Mpo","Lpo","Elane" ,"Sorcs2","Pax5","Ror1","Tmtc1","C1qa","C1qb","Ms4a7","Apoe","Fcrls","Cdk8","Lars2","Plec","S100a10","F13a1","Ly6c2","Crip1" ,"Ccr2" ,"Lyz2", "Tgfbi","Mrc1","Ust","H2-Aa","Cd74","Atf3" ,"Klf13"   , "Grk5"  ,"Dock5"  , "Cyp2ab1" ,  "Ace","Ear2","Ank1","Gypa","Aqp1","Car2","Hbb-bt" ,"Ccr7","Cd79a","Ms4a1","Ebf1","Dntt","Mki67","Stmn1","nucleosome_signal","nucleosome_percentile","TSS.enrichment","TSS.percentile","pct_reads_in_peaks","blacklist_ratio"))+RotatedAxis()+theme(axis.title = element_blank())
```


```{r , fig.height = 3, fig.width = 10}
meta.data<-seur@meta.data %>%
    dplyr::group_by(annot,origin) %>%
    dplyr::summarise(count=dplyr::n())%>% suppressMessages()%>%
    dplyr::group_by(annot) %>%
    dplyr::mutate(perc.per.group = (count / sum(count))*100)  
ggplot(meta.data, aes(x=annot, y=perc.per.group, fill=origin))+
    geom_bar(stat = "identity")+
    theme_classic()+
    theme(axis.title.x=element_blank(),
          axis.text = element_text(size=12),
          axis.title.y = element_text(size=12),
          legend.text=element_text(size=12),
          legend.title=element_text(size=12))+
    ylab("% cells per cluster")+RotatedAxis()
```

```{r}
saveRDS(seur,paste0("Integrated.BM.and.FL_monocytes_snATACseq_JBA1-2.seurat.rds"))
```




```{r,warning=FALSE}
sessionInfo()
```
